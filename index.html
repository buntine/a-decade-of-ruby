<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>A decade of Ruby</title>

    <link rel="stylesheet" href="/css/reveal.css">
    <link rel="stylesheet" href="/css/theme/white.css">
    <link rel="stylesheet" href="/lib/css/zenburn.css">
    <link rel="stylesheet" href="/css/custom.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section><img class="logo" src="/lib/image/logo.png" alt="Ruby logo" /></section>
        <section>Hi! I'm <strong>Andrew Buntine</strong></section>
        <section>The Technical Director at <strong>Hardhat Digital</strong></section>
        <section>I also publish code at <strong>github.com/buntine</strong></section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            def sum(numbers)
              total = 0

              for n in numbers do
                total = total + n
              end

              total
            end
          </code></pre>
        </section>
        <section>
          <!-- The higher-order function 'reduce' can perform the same task without requiring a mutated running variable.
          -->
          <pre><code data-trim data-noescape class="ruby">
            def sum(numbers)
              numbers.reduce(0) do |total, n|
                total + n
              end
            end
          </code></pre>
        </section>
        <section>
          <!-- If we pass a symbol, the method it names will be applied to each item in the collection (along with an accumulator).
          -->
          <pre><code data-trim data-noescape class="ruby">
            def sum(numbers)
              numbers.reduce(0, :+)
            end
          </code></pre>
        </section>
        <section>
          <!-- First argument defaults to the first item in the collection.
               And now the abstraction is not even necessary.
          -->
          <pre><code data-trim data-noescape class="ruby">
            numbers.reduce(:+)
          </code></pre>
        </section>
        <section>
          <!-- Performance hit.
               Some languages smart enough to optimise. Ruby is not one of them.
          -->
          <pre><code data-trim data-noescape class="ruby">
            def sum_multiples(numbers, multiple)
              numbers
                .reject { |n| n % multiple &gt; 0}
                .reduce(:+)
            end
          </code></pre>
        </section>
        <section>
          <p>We've just seen a lot!</p>
        </section>
        <section>
          <p>Higher-order functions can be very powerful</p>
        </section>
        <section>
          <p>Weigh your options - performance matters</p>
        </section>
        <section>
          <p>Refactoring is an important part of programming</p>
        </section>
        <section>
          <p>Learn when to define abstractions</p>
        </section>
        <section>
          <p>Always look for patterns of code smells</p>
        </section>
        <section>
          <p>Know the standard libraries well</p>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
          class MonthlyData
            def january
              fetch_data(1)
            end

            def february
              fetch_data(2)
            end

            def march
              fetch_data(3)
            end

            # ...
          end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            class MonthlyData
              Date::MONTHNAMES.each_with_index do |mn, i|
                define_method(mn.downcase) do
                  fetch_data(i)
                end
              end
            end
          </code></pre>
        </section>
        <section>
          <!-- Static data extremely unlikely to change. 
               Not enough of them to warrant complexity.
          -->
          <pre><code data-trim data-noescape class="ruby">
            class Request
              POSSIBLE_VERBS = ['get', 'put', 'post', 'delete']

              def method_missing(s, *args, &amp;b)
                if POSSIBLE_VERBS.include? s
                  begin
                    r.send(s, *args, &amp;b)
                  rescue RestClient::RequestFailed =&gt; e
                    print STDERR, e.response.body
                    raise e
                  end
                else
                  super
                end
              end
            end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            class Request
              def get(*args, &amp;b)
                r.get(*args, &amp;b)
              end

              def post(*args, &amp;b)
                r.post(*args, &amp;b)
              end

              # ...
            end
          </code></pre>
        </section>
        <section>
          <!-- Simpler, non-meta version of the months example.
          -->
          <pre><code data-trim data-noescape class="ruby">
            class MonthlyData
              def for_month(m)
                fetch_data(Date::MONTHNAMES.index(m))
              end
            end
          </code></pre>
        </section>
        <section>
          <p>Metaprogramming is a very powerful technique</p>
        </section>
        <section>
          <p>But it's a double-edged sword that should be handled carefully!</p>
        </section>
        <section>
          <p>Often, a non-meta solution is much simpler to maintain in the long term</p>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            def excited(sentence, amount=1)
              "#{sentence}#{"!" * amount}"
            end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            sentence = "Awesome"
            puts excited(sentence, 2)  # "Awesome!!"
          </code></pre>
        </section>
        <section>
          <!-- Open class example.
               Monkey-patching or Duck-punching.
          -->
          <pre><code data-trim data-noescape class="ruby">
            class String
              def excited(amount=1)
                "#{self}#{"!" * amount}"
              end
            end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            puts "Awesome".excited(2)  # "Awesome!!"
          </code></pre>
        </section>
        <section>
          <!-- Favours syntax over semantics.
               Now Fixnum has a method that returns a date (actually an ActiveSupport::Duration)! It has no business being coupled to Date.
               But it's beautiful to look at.
          -->
          <pre><code data-trim data-noescape class="ruby">
            3.days.ago
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            def first_friend
              friends = JSON
                          .parse(File.read("friends.json"))
                          .sort { |a, b| a["date"] <=> b["date"] }

              friends.first
            end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            def last_friend
              friends = JSON
                          .parse(File.read("friends.json"))
                          .sort { |a, b| b["date"] <=> a["date"] }

              friends.first
            end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            def find_friend(&amp;b)
              friends = JSON.parse(File.read("friends.json"))
              sorted = yield friends              

              sorted.first
            end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            find_friend do |fs|
              fs.sort { |a, b| a["date"] <=> b["date"] }
            end
          </code></pre>
        </section>
        <section>
          <pre><code data-trim data-noescape class="ruby">
            find_friend do |fs|
              fs.sort { |a, b| b["date"] <=> a["date"] }
            end
          </code></pre>
        </section>
        <section>
          First-class functions are one of the greatest (and oldest!) ideas in all of computer science
        </section>
        <section>
          Ruby's blocks allow us to write generic functions
        </section>
        <section>
          Data structures.
        </section>
        <section>
          Recursion? Fib.
        </section>
        <section>
          REPL-oriented programming.
        </section>
      </div>
    </div>

    <script src="/lib/js/head.min.js"></script>
    <script src="/js/reveal.js"></script>
    <script>
      Reveal.initialize({
        history: true,
        dependencies: [
          { src: '/plugin/markdown/marked.js' },
          { src: '/plugin/markdown/markdown.js' },
          { src: '/plugin/notes/notes.js', async: true },
          { src: '/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
